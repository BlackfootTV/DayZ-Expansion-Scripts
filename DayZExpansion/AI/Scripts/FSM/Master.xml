<?xml version="1.0" encoding="utf-8"?>
<fsm name="Master" type="eAI">
	<files>
		<file name="Vehicles" />
		<file name="Fighting" />
		<file name="Reloading" />
	</files>
	<states default="Idle">
		<state name="Idle">
			<variables />
			<editor_data>
				<position x="544" y="329" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				if (!unit.GetTarget())
				{
					if (unit.GetLookDirectionRecalculate())
						unit.LookAtDirection("0 0 1");
				
					if (unit.GetAimDirectionRecalculate())
						unit.AimAtDirection("0 0 1");
				}
				
				auto hands = unit.GetItemInHands();
				if (hands &amp;&amp; hands.HasEnergyManager() &amp;&amp; hands.GetCompEM().IsWorking() &amp;&amp; hands.GetCompEM().CanSwitchOff())
				{
					hands.GetCompEM().SwitchOff();
				}
				
				unit.OverrideMovementDirection(false, 0);
				unit.OverrideMovementSpeed(true, 0);
				unit.Expansion_GetUp();
			</event_entry>
			<event_exit />
			<event_update>
				return EXIT;
			</event_update>
		</state>
		<state name="Unconscious">
			<variables>
				<variable name="time" type="float" />
			</variables>
			<editor_data>
				<position x="892.021210954633" y="252.363165761721" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				time = 0;
				unit.OverrideTargetPosition(unit.GetPosition());
			</event_entry>
			<event_exit />
			<event_update>
				if (time &gt; 3)
				{
					return EXIT;
				}
				
				if (!unit.IsUnconscious())
				{
					time += DeltaTime;  //! Allow time to stand up so we don't instantly start firing
				}
				
				return CONTINUE;
			</event_update>
		</state>
		<state name="Trading">
			<variables />
			<editor_data>
				<position x="646.85281251958" y="173.442104279785" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.OverrideTargetPosition(unit.GetPosition());
			</event_entry>
			<event_exit />
			<event_update>
				if (unit.IsTrading())
				{
					return CONTINUE;
				}
				return EXIT;
			</event_update>
		</state>
		<state name="FollowFormation">
			<variables>
				<variable name="group" type="eAIGroup" />
				<variable name="speedLimit" type="int" />
			</variables>
			<editor_data>
				<position x="705.506428737142" y="490.855335435811" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.Expansion_GetUp();
				speedLimit = unit.GetMovementSpeedLimit();
			</event_entry>
			<event_exit>
				unit.SetMovementSpeedLimit(speedLimit);  //! Restore speed limit
			</event_exit>
			<event_update>
				unit.OverrideTargetPosition(group.GetFormationPosition(unit));
				unit.OverrideMovementDirection(false, 0);
				unit.OverrideMovementSpeed(false, 0);
				unit.SetMovementSpeedLimit(3);  //! Make sure AI can reach formation positions when following leader by overriding speed limit 
				
				return EXIT;
			</event_update>
		</state>
		<state name="TraversingWaypoints">
			<variables>
				<variable name="path" type="ref TVectorArray" />
				<variable name="behaviour" type="eAIWaypointBehavior" />
				<variable name="backtracking" type="bool" />
				<variable name="index" type="int" />
				<variable name="threshold" type="float" default="1.0" />
				<variable name="previousDistance" type="float" />
			</variables>
			<editor_data>
				<position x="492.26310970946" y="542.205251357419" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				path = unit.GetGroup().GetWaypoints();
				if (path.Count() == 0)
				{
					path = { unit.GetPosition() };
				}
				behaviour = unit.GetGroup().GetWaypointBehaviour();
				unit.Expansion_GetUp();
			</event_entry>
			<event_exit />
			<event_update>
				vector direction = vector.Direction(unit.GetPosition(), path[index]);
				float distance = direction.LengthSq();
				if (distance &lt; threshold)
				{
					if (backtracking) index--;
					else index++;
					threshold = 1.0;
				}
				else if (Math.AbsFloat(distance - previousDistance) &lt; 0.01)
				{
					//! We seem to not be getting closer to the waypoint, possibly the path is blocked.
					//! Increase threshold until we are within distance.
					threshold += 0.01;
				}
				
				previousDistance = distance;
				
				if (index &lt; 0) 
				{
					if (behaviour == eAIWaypointBehavior.ALTERNATE)
					{
						backtracking = false;
						index = 1;
					}
				}
				else if (index == path.Count())
				{
					if (behaviour == eAIWaypointBehavior.ALTERNATE)
					{
						backtracking = true;
						index = path.Count() - 2;
					} 
					else if (behaviour == eAIWaypointBehavior.LOOP)
					{
						backtracking = false;
						index = 0;
					}
				}
				
				index = Math.Clamp(index, 0, path.Count() - 1);
				
				bool isFinal;
				if (behaviour != eAIWaypointBehavior.LOOP)
					isFinal = index == 0 || index == path.Count() - 1;
				
				unit.OverrideTargetPosition(path[index], isFinal);
				unit.OverrideMovementDirection(false, 0);
				unit.OverrideMovementSpeed(false, 0);
				
				unit.Expansion_DebugObject_Deferred(index + 12, path[index] - "0 1.5 0", "ExpansionDebugNoticeMe_Red", direction.Normalized());
				unit.Expansion_DebugObject_Deferred(path.Count() + 12, path[index], "ExpansionDebugNoticeMe", direction.Normalized());
				
				return EXIT;
			</event_update>
		</state>
		<state name="Vehicles" fsm="Vehicles">
			<variables />
			<editor_data>
				<position x="895.709194546504" y="371.938198458873" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry />
			<event_exit />
			<event_update />
		</state>
		<state name="Fighting" fsm="Fighting">
			<variables />
			<editor_data>
				<position x="345.886600687191" y="193.617136976937" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.UpdateAimArbitration();
				if (unit.GetEmoteManager().IsEmotePlaying())
					unit.GetEmoteManager().ServerRequestEmoteCancel();
			</event_entry>
			<event_exit>
				unit.StopAimArbitration();
			</event_exit>
			<event_update>
				return EXIT;
			</event_update>
		</state>
		<state name="Weapon_Reloading" fsm="Reloading">
			<variables />
			<editor_data>
				<position x="241.837936881654" y="365.435451333598" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.UpdateAimArbitration();
				if (unit.GetEmoteManager().IsEmotePlaying())
					unit.GetEmoteManager().ServerRequestEmoteCancel();
			</event_entry>
			<event_exit>
				unit.StopAimArbitration();
			</event_exit>
			<event_update />
		</state>
		<state name="Weapon_Unjamming">
			<variables>
				<variable name="weapon" type="Weapon_Base" />
				<variable name="time" type="float" />
				<variable name="failed_attempts" type="int" />
			</variables>
			<editor_data>
				<position x="241.678975886238" y="283.953840426607" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				time = 0;
				unit.RaiseWeapon(true);
				
				unit.StartActionObject(eAIActionWeaponUnjam, null);
			</event_entry>
			<event_exit>
				unit.RaiseWeapon(false);
				unit.OverrideMovementDirection(false, 0);
			</event_exit>
			<event_update>
				if (!unit.GetWeaponManager()) return EXIT;
				
				if (unit.GetWeaponManager().IsRunning())
				{
					time += DeltaTime;
					if (time &gt; 10)  //! Looks like something went terribly wrong
					{
						EXTrace.Print(true, unit, "Weapon_Unjamming - timeout");
						unit.eAI_Unbug("unjam");
						return EXIT;
					}
					
					auto target = unit.GetTarget();
					if (target &amp;&amp; target.GetDistanceSq(unit) &lt;= 2.25)
					{
						unit.OverrideMovementDirection(true, -180);
					}
				
					return CONTINUE;
				}
				
				if (unit.GetWeaponManager().CanUnjam(weapon))
				{
					failed_attempts++;
					EXTrace.Print(true, unit, "Weapon_Unjamming - failed (" + failed_attempts + ")");
					weapon.ValidateAndRepair();
					if (failed_attempts &gt; 5)
					{
						unit.eAI_DropItem(weapon);
					}
				}
				else
				{
					failed_attempts = 0;
				}
				
				return EXIT;
			</event_update>
		</state>
		<state name="TakeItemToHands">
			<variables>
				<variable name="item" type="ItemBase" />
				<variable name="time" type="float" />
			</variables>
			<editor_data>
				<position x="275.340877794781" y="547.920853681019" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				EXTrace.Print(EXTrace.AI, unit, "TakeItemToHands " + item.ToString());
				time = 0;
				
				if (!GetGame().IsMultiplayer())
				{
					//! It's that simple in offline. Why can't it be that simple in MP? :-(
					unit.LocalTakeEntityToHands(item);
				}
				else
				{
					unit.Expansion_CloneItemToHands(item);
				}
			</event_entry>
			<event_exit />
			<event_update>
				if (time &lt; 1.0)
				{
					//! Wait briefly before doing anything to prevent cloning to hands failing or scuffed weapon holding
					time += DeltaTime;
					return CONTINUE;
				}
				
				return EXIT;
			</event_update>
		</state>
		<state name="Bandaging_Self">
			<variables>
				<variable name="last_bandage_attempt_time" type="int" />
				<variable name="bandage" type="ItemBase" />
				<variable name="timeout" type="float" />
				<variable name="time" type="float" />
			</variables>
			<editor_data>
				<position x="246.619877794781" y="467.752853681019" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				last_bandage_attempt_time = GetGame().GetTime();
				time = 0;
				float effectivity = bandage.GetBandagingEffectivity();
				if (effectivity &gt; 0)
					timeout = UATimeSpent.BANDAGE / effectivity + 8.0;
				else
					timeout = 16.0;
			</event_entry>
			<event_exit>
				unit.Expansion_GetUp(true);
				if (bandage)
				{
					if (bandage.GetHealth() &lt;= 0.0 || !unit.Expansion_CloneItemToInventory(bandage))
					{
						unit.eAI_DropItem(bandage);
					}
				}
			</event_exit>
			<event_update>
				if (unit.GetActionManager().GetRunningAction())
				{
					time += DeltaTime;
					if (time &gt; timeout)  //! Looks like something went terribly wrong
					{
						EXTrace.Print(true, unit, "Bandaging_Self - timeout");
						unit.eAI_Unbug("bandage");
						time = 0;
						return EXIT;
					}
					
					return CONTINUE;
				}
				else
				{
					if (bandage)
					{
						if (unit.GetBleedingSourceCount() &amp;&amp; bandage.GetHealth() &gt; 0.0)
						{
							last_bandage_attempt_time = GetGame().GetTime();
							time = 0;
							
							unit.StartActionObject(ActionBandageSelf, null);
							
							return CONTINUE;
						}
					}
				}
				
				return EXIT;
			</event_update>
		</state>
		<state name="PlayEmote">
			<variables />
			<editor_data>
				<position x="445.886600687191" y="293.617136976937" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.Expansion_PlayEmote();
			</event_entry>
			<event_exit />
			<event_update>
				return EXIT;
			</event_update>
		</state>
	</states>
	<transitions>
		<transition>
			<editor_data>
				<position_source x="938.972336543873" y="229.798443463138" />
				<position_destination x="939.021210954633" y="252.363165761721" />
			</editor_data>
			<guard>
				if (!(unit.IsUnconscious())) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Unconscious" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="892.021210954633" y="273.262936077279" />
				<position_destination x="694" y="341.086651264055" />
			</editor_data>
			<guard>
				if (unit.IsUnconscious()) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Unconscious" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="719.985399543115" y="150.091827885125" />
				<position_destination x="719.85281251958" y="173.442104279785" />
			</editor_data>
			<guard>
				if (!(unit.IsTrading())) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Trading" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="708.131447011985" y="213.442104279785" />
				<position_destination x="637.094556721445" y="329" />
			</editor_data>
			<guard>
				if (unit.IsTrading()) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Trading" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="323.444352352527" y="441.721949556564" />
				<position_destination x="323.444352352527" y="467.752853681019" />
			</editor_data>
			<guard>
				if (unit.IsInMelee()) return FAIL;
				
				if (!unit.GetBleedingSourceCount()) return FAIL;
				
				if (GetGame().GetTime() - dst.last_bandage_attempt_time &lt; 4000) return FAIL;
				
				auto hands = unit.GetItemInHands();
				if (!hands) return FAIL;
				
				if (!(hands.IsInherited(BandageDressing) || hands.IsInherited(Rag)) || hands.GetHealth() &lt;= 0.0) return FAIL;
				
				dst.bandage = hands;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Bandaging_Self" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="392.845475445666" y="467.752853681019" />
				<position_destination x="558.183798920839" y="369" />
			</editor_data>
			<guard>
				if (unit.GetActionManager().GetRunningAction()) return FAIL;
				
				if (GetGame().GetTime() - src.last_bandage_attempt_time &lt; 4000) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Bandaging_Self" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="638.223504581552" y="369" />
				<position_destination x="723.010348161875" y="490.855335435811" />
			</editor_data>
			<guard>
				if (unit.GetThreatToSelf() &gt; 0.4) return FAIL;
				
				dst.group = unit.GetGroup();
				if (!dst.group) return FAIL;
				
				if (dst.group.GetFormationState() != eAIGroupFormationState.IN) return FAIL;
				
				auto leader = dst.group.GetLeader();
				if (!leader || leader == unit) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Idle" />
			<to_state name="FollowFormation" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="604.355068778326" y="369" />
				<position_destination x="624.401116247196" y="542.205251357419" />
			</editor_data>
			<guard>
				if (unit.GetThreatToSelf() &gt; 0.4) return FAIL;
				
				auto group = unit.GetGroup();
				if (!group) return FAIL;
				
				// we are the leader so we traverse the waypoints
				auto leader = group.GetLeader();
				if (leader &amp;&amp; leader != unit) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Idle" />
			<to_state name="TraversingWaypoints" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="611.41821585596" y="542.205251357419" />
				<position_destination x="591.936642317143" y="369" />
			</editor_data>
			<guard>
				if (unit.GetThreatToSelf() &gt; 0.4) return SUCCESS;
				
				return FAIL;
			</guard>
			<event />
			<from_state name="TraversingWaypoints" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="738.815618203381" y="490.855335435811" />
				<position_destination x="652.899826762951" y="369" />
			</editor_data>
			<guard>
				auto group = unit.GetGroup();
				if (group &amp;&amp; group.GetFormationState() != eAIGroupFormationState.IN) return SUCCESS;
				
				if (unit.GetThreatToSelf() &gt; 0.4) return SUCCESS;
				
				return FAIL;
			</guard>
			<event />
			<from_state name="FollowFormation" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="305.386520870577" y="339.219542313248" />
				<position_destination x="304.837936881655" y="365.435451333598" />
			</editor_data>
			<guard>
				if (GetGame().GetTime() - dst.sub_fsm.last_attempt_time &lt; 5000) return FAIL;
				
				if (unit.IsInMelee()) return FAIL;
				
				if (!Class.CastTo(dst.sub_fsm.weapon, unit.GetItemInHands())) return FAIL;
				
				//! Allow sub-FSM to handle destroyed weapon so it gets dropped
				if (dst.sub_fsm.weapon.IsDamageDestroyed()) return SUCCESS;
				
				int mi = dst.sub_fsm.weapon.GetCurrentMuzzle();
				bool isChamberEmpty = dst.sub_fsm.weapon.IsChamberEmpty(mi);
				bool isChamberFiredOut = dst.sub_fsm.weapon.IsChamberFiredOut(mi);
				if (!(isChamberFiredOut || isChamberEmpty)) return FAIL;
				
				if (unit.GetWeaponManager().CanUnjam(dst.sub_fsm.weapon)) return FAIL;
				
				// don't move to the state if the action manager is operating
				if (!unit.GetActionManager() || unit.GetActionManager().GetRunningAction()) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Weapon_Reloading" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="344.344352352527" y="520.921949556564" />
				<position_destination x="345.340877794781" y="547.920853681019" />
			</editor_data>
			<guard>
				if (unit.IsInMelee()) return FAIL;
				
				//! Taking items to hands while raised breaks hands! Wait until lowered
				if (unit.IsRaised()) return FAIL;
				
				ItemBase hands = unit.GetItemInHands();
				
				//! First check if we want to switch to bandage
				if (unit.GetBleedingSourceCount() &amp;&amp; unit.GetThreatToSelf(true) &lt; 0.4)
				{
					if (!hands || !(hands.IsInherited(BandageDressing) || hands.IsInherited(Rag)) || hands.GetHealth() &lt;= 0.0)
					{
						//! Item in hand is either not bandage/rag or is ruined
						dst.item = unit.GetBandageToUse();
						if (dst.item)
						{
							//! If ruined, drop, else put in inventory (shoulder slot or cargo)
							if (hands &amp;&amp; (hands.GetHealth() &lt;= 0.0 || !unit.Expansion_CloneItemToInventory(hands)))
								unit.eAI_DropItem(hands);
							
							return SUCCESS;
						}
					}
				}
				
				if (hands)
					return FAIL;
				
				dst.item = unit.GetWeaponToUse(true);
				if (dst.item)
					return SUCCESS;
				
				eAITarget target = unit.GetTarget();
				if (target &amp;&amp; target.GetEntity().IsInherited(ItemBase))
				{
					if (target.GetDistanceSq(unit) &lt; 2.25 &amp;&amp; target.GetThreat(unit) &gt; 0.1)
					{
						dst.item = ItemBase.Cast(target.GetEntity());
					}
				}
				
				if (dst.item)
					return SUCCESS;
				
				dst.item = unit.GetMeleeWeaponToUse();
				if (dst.item)
					return SUCCESS;
				
				 return FAIL;
			</guard>
			<event />
			<from_state />
			<to_state name="TakeItemToHands" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="425.340877794781" y="566.587863735993" />
				<position_destination x="587.553377501537" y="369" />
			</editor_data>
			<guard>
				return SUCCESS;
			</guard>
			<event />
			<from_state name="TakeItemToHands" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="309.931260171115" y="257.964244245612" />
				<position_destination x="310.678975886238" y="283.953840426607" />
			</editor_data>
			<guard>
				if (unit.IsInMelee()) return FAIL;
				
				if (!Class.CastTo(dst.weapon, unit.GetItemInHands())) return FAIL;
				
				if (!unit.GetWeaponManager().CanUnjam(dst.weapon)) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Weapon_Unjamming" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="391.837936881654" y="380.990613137228" />
				<position_destination x="544" y="360.278764885883" />
			</editor_data>
			<guard>
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Weapon_Reloading" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="391.678975886238" y="304.815580440075" />
				<position_destination x="544" y="346.731390564592" />
			</editor_data>
			<guard>
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Weapon_Unjamming" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="411.536567580795" y="166.157628667599" />
				<position_destination x="411.886600687193" y="193.617136976937" />
			</editor_data>
			<guard>
				if (unit.GetThreatToSelf(true) &lt; 0.4) return FAIL;
				if (unit.GetActionManager().GetRunningAction()) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Fighting" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="477.015543467033" y="233.617136976937" />
				<position_destination x="556.939258653809" y="329" />
			</editor_data>
			<guard>
				if (unit.GetThreatToSelf() &gt; 0.2) return FAIL;
				
				if (unit.IsInMelee()) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Fighting" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="963.83813732635" y="345.935333753678" />
				<position_destination x="963.7091945465" y="371.938198458873" />
			</editor_data>
			<guard>
				auto group = unit.GetGroup();
				if (!group) return FAIL;
				
				if (group.GetFormationState() != eAIGroupFormationState.IN) return FAIL;
				
				auto leader = group.GetLeader();
				if (!leader || leader == unit) return FAIL;
				
				if (!leader.IsInTransport()) return FAIL;
				
				Transport transport;
				if (!Class.CastTo(transport, leader.GetParent())) return FAIL;
				
				//TODO: make this event based instead and store as a variable within CarScript.
				//Prevents looping through the crew and insteads just compares a bool.
				for (int i = 1; i &lt; transport.CrewSize(); i++)
				{
					if (transport.CrewMember(i) == null)
					{
				  			return SUCCESS;
					}
				}
				
				return FAIL;
			</guard>
			<event />
			<from_state />
			<to_state name="Vehicles" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="895.709194546504" y="389.964300297873" />
				<position_destination x="694" y="356.89192130556" />
			</editor_data>
			<guard>
				return SUCCESS;
			</guard>
			<event />
			<from_state name="Vehicles" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="995.709194546504" y="489.964300297873" />
				<position_destination x="794" y="456.89192130556" />
			</editor_data>
			<guard>
				if (!unit.m_Expansion_EmoteID) return FAIL;
				if (unit.GetEmoteManager().IsEmotePlaying() || unit.GetEmoteManager().Expansion_GetCurrentGesture() == unit.m_Expansion_EmoteID) return FAIL;
				if (unit.GetThreatToSelf(true) &gt; 0.2) return FAIL;
				if (unit.IsInMelee()) return FAIL;
				if (unit.GetWeaponManager().IsRunning()) return FAIL;
				if (unit.GetActionManager().GetRunningAction()) return FAIL;
				
				auto hands = unit.GetItemInHands();
				if (hands &amp;&amp; (hands.IsInherited(BandageDressing) || hands.IsInherited(Rag)))
					return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="PlayEmote" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="1095.709194546504" y="589.964300297873" />
				<position_destination x="894" y="556.89192130556" />
			</editor_data>
			<guard>
				return SUCCESS;
			</guard>
			<event />
			<from_state name="PlayEmote" />
			<to_state name="Idle" />
		</transition>
	</transitions>
</fsm>