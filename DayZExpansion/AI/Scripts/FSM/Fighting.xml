<?xml version="1.0" encoding="utf-8"?>
<fsm name="Fighting" type="eAI">
	<files />
	<variables>
		<variable name="LastFireTime" type="int" />
		<variable name="TimeBetweenFiring" type="int" default="5000" />
	</variables>
	<states default="Positioning">
		<state name="Positioning">
			<variables>
				<variable name="position" type="vector" />
				<variable name="time" type="float" />
				<variable name="movementDirection" type="float" />
			</variables>
			<editor_data>
				<position x="891" y="714" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				time = 0;
			</event_entry>
			<event_exit />
			<event_update>
				bool wantsLower = false;
				bool wantsRaise = false;
				
				if (GetGame().GetTime() - fsm.LastFireTime &gt; fsm.TimeBetweenFiring)
				{
					wantsLower = true;
				}
				
				auto target = unit.GetTarget();
				if (target)
				{
					position = target.GetPosition(unit);
					auto aimPosition = position + target.GetAimOffset(unit);
					auto distanceSq = vector.DistanceSq(unit.GetPosition(), position);
					
					bool shouldBeMeleeing = false;
				
					auto hands = unit.GetHumanInventory().GetEntityInHands();
					if (target.GetEntity().IsInherited(ItemBase))
					{
						wantsLower = true;
					}
					else if (!hands)
					{
						shouldBeMeleeing = true;
					}
					else if (hands.IsWeapon())
					{
						if (distanceSq &lt;= 2.25)
						{
							shouldBeMeleeing = true;
						}
					}
					else if (hands.IsMeleeWeapon())
					{
						shouldBeMeleeing = true;
					}
					
					if (shouldBeMeleeing)
					{
						if (distanceSq &lt;= 3.24)
						{
							wantsRaise = true;
						}
						else
						{
							wantsLower = true;
						}
					}
				
					if (distanceSq &lt;= 1.0)
					{
						time += DeltaTime;
						//unit.OverrideStance(DayZPlayerConstants.STANCEIDX_RAISEDERECT);
						if (!movementDirection || time &gt; Math.RandomIntInclusive(1, 3))
						{
							if (Math.RandomIntInclusive(0, 1))
								movementDirection = Math.RandomFloat(135, 180);
							else
								movementDirection = Math.RandomFloat(-135, -180);
						}
						unit.OverrideMovementDirection(true, movementDirection);
						unit.OverrideMovementSpeed(true, Math.RandomIntInclusive(1, 2));
					}
					else
					{
						//unit.OverrideStance(0);
						unit.OverrideMovementDirection(false, 0);
						unit.OverrideMovementSpeed(false, 0);
						time = 0;
						movementDirection= 0;
					}
				
					unit.LookAtPosition(aimPosition);
					unit.AimAtPosition(aimPosition);
					unit.OverrideTargetPosition(position);
					
					if (hands &amp;&amp; (hands.IsWeapon() || distanceSq &lt;= 100.0))
					{
						if (hands.HasEnergyManager() &amp;&amp; !hands.GetCompEM().IsWorking() &amp;&amp; hands.GetCompEM().CanSwitchOn())
						{
							hands.GetCompEM().SwitchOn();
						}
					}
				}
				else
				{
					unit.OverrideMovementDirection(false, 0);
					unit.OverrideMovementSpeed(false, 0);
				}
				
				if (wantsRaise &amp;&amp; unit.CanRaiseWeapon())
				{
					unit.RaiseWeapon(true);
				}
				else if (wantsLower || !unit.CanRaiseWeapon())
				{
					unit.RaiseWeapon(false);
				}
				
				return EXIT;
			</event_update>
		</state>
		<state name="FireWeapon">
			<variables>
				<variable name="time" type="float" />
				<variable name="target" type="eAITarget" />
			</variables>
			<editor_data>
				<position x="618.636363636364" y="715.727272727273" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.RaiseWeapon(true);
				
				time = 0;
				
				fsm.LastFireTime = GetGame().GetTime();
			</event_entry>
			<event_exit />
			<event_update>
				if (!target)
					return EXIT;
				
				auto lowPosition = target.GetPosition(unit);
				auto aimPosition = lowPosition + target.GetAimOffset(unit);
				
				time += DeltaTime;
				unit.OverrideTargetPosition(lowPosition);
				unit.LookAtPosition(aimPosition);
				unit.AimAtPosition(aimPosition);
				
				if (!unit.IsRaised() || !unit.IsWeaponRaiseCompleted())
				{
					unit.RaiseWeapon(true);
				
					if (time &gt;= 0.5)
					{
						return EXIT;
					}
				
					// waiting for the weapon to be raised
					return CONTINUE;
				}
				
				unit.TryFireWeapon();
				
				return EXIT;
			</event_update>
		</state>
		<state name="Melee">
			<variables>
				<variable name="time" type="float" />
				<variable name="target" type="eAITarget" />
				<variable name="movementDirection" type="float" />
			</variables>
			<editor_data>
				<position x="1155" y="711" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				time = 0;
				
				fsm.LastFireTime = GetGame().GetTime();
				
				unit.Expansion_GetUp();
				
				//! FIXME: Pistols fuck up the hand animation state.
				//! Ugly workaround: Put away when entering melee.
				auto hands = unit.GetItemInHands();
				if (hands &amp;&amp; hands.IsKindOf("Pistol_Base"))
				{
					unit.Expansion_CloneItemToInventory(hands);
				}
			</event_entry>
			<event_exit />
			<event_update>
				if (!target)
					return EXIT;
				
				auto aimOffset = target.GetAimOffset(unit);
				
				//! FIXME: We can't hit crouching/crawling targets w/ melee
				if (aimOffset[1] &lt; 1.0) return EXIT;
				
				auto lowPosition = target.GetPosition(unit);
				auto aimPosition = lowPosition + aimOffset;
				
				time += DeltaTime;
				unit.OverrideTargetPosition(lowPosition);
				unit.LookAtPosition(aimPosition);
				unit.AimAtPosition(aimPosition);
				
				float distanceSq = target.GetDistanceSq(unit);
				if (distanceSq &gt; 2.25)
				{
					if (time &gt;= 0.5)
					{
						time = 0;
						return EXIT;
					}
				
					return CONTINUE;
				}
				
				auto direction = vector.Direction(unit.GetPosition(), lowPosition).Normalized();
				if (vector.Dot(unit.GetDirection(), direction) &lt; 0.75)
				{
					if (time &gt;= Math.RandomIntInclusive(1, 3))
					{
						//unit.OverrideStance(0);
						unit.OverrideMovementDirection(false, 0);
						unit.OverrideMovementSpeed(false, 0);
						time = 0;
						movementDirection = 0;
						return EXIT;
					}
				
					//unit.OverrideStance(DayZPlayerConstants.STANCEIDX_RAISEDERECT);
					if (!movementDirection || time &gt; Math.RandomIntInclusive(1, 3))
					{
						if (Math.RandomIntInclusive(0, 1))
							movementDirection = Math.RandomFloat(135, 180);
						else
							movementDirection = Math.RandomFloat(-135, -180);
					}
					unit.OverrideMovementDirection(true, movementDirection);
					unit.OverrideMovementSpeed(true, Math.RandomIntInclusive(1, 2));
				
					return CONTINUE;
				}
				
				if (unit.IsInMelee() &amp;&amp; time &lt; 0.3)
				{
					return CONTINUE;
				}
				
				unit.Notify_Melee();
				time = 0;
				movementDirection = 0;
				
				return EXIT;
			</event_update>
		</state>
	</states>
	<transitions>
		<transition>
			<editor_data>
				<position_source x="1229" y="680" />
				<position_destination x="1228" y="711" />
			</editor_data>
			<guard>
				// we are targetting an entity?
				dst.target = unit.GetTarget();
				if (!dst.target || !dst.target.IsMeleeViable(unit)) return FAIL;
				
				//! FIXME: We can't hit crouching/crawling targets w/ melee
				if (dst.target.GetAimOffset(unit)[1] &lt; 1.0) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Melee" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="696.636363636364" y="687.727272727273" />
				<position_destination x="696.636363636364" y="715.727272727273" />
			</editor_data>
			<guard>
				// we are aiming at something?
				dst.target = unit.GetTarget();
				if (!dst.target) return FAIL;
				
				if (unit.IsInMelee()) return FAIL;
				
				// we are holding a weapon
				Weapon_Base weapon;
				if (!Class.CastTo(weapon, unit.GetItemInHands())) return FAIL;
				
				// CanRaiseWeapon will return false if there is no line of sight
				if (!unit.CanRaiseWeapon()) return FAIL;
				
				if (!weapon.Expansion_IsChambered()) return FAIL;
				
				if (unit.GetWeaponManager().CanUnjam(weapon)) return FAIL;
				
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="FireWeapon" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="970" y="682" />
				<position_destination x="969" y="714" />
			</editor_data>
			<guard>
				return SUCCESS;
			</guard>
			<event />
			<from_state />
			<to_state name="Positioning" />
		</transition>
	</transitions>
</fsm>